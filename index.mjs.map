{"version":3,"file":"index.mjs","sources":["../lib/main.js","../lib/validate.js","../lib/index_of_types.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this */\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport hasProp from '@stdlib/assert-has-property';\nimport isndarrayLike from '@stdlib/assert-is-ndarray-like';\nimport isObject from '@stdlib/assert-is-object';\nimport isFunction from '@stdlib/assert-is-function';\nimport isCollection from '@stdlib/assert-is-collection';\nimport isEmptyCollection from '@stdlib/assert-is-empty-collection';\nimport isFunctionArray from '@stdlib/assert-is-function-array';\nimport isDataType from '@stdlib/ndarray-base-assert-is-data-type';\nimport contains from '@stdlib/array-base-assert-contains';\nimport nullaryStrided1d from '@stdlib/ndarray-base-nullary-strided1d';\nimport resolveEnum from '@stdlib/ndarray-base-dtype-resolve-enum';\nimport ndims from '@stdlib/ndarray-ndims';\nimport getDType from '@stdlib/ndarray-base-dtype';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport join from '@stdlib/array-base-join';\nimport copy from '@stdlib/array-base-copy';\nimport everyBy from '@stdlib/array-base-every-by';\nimport objectAssign from '@stdlib/object-assign';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport defaults from './defaults.json';\nimport validate from './validate.js';\nimport indexOfTypes from './index_of_types.js';\n\n\n// FUNCTIONS //\n\n/**\n* Returns a list of data type enumeration constants.\n*\n* @private\n* @param {Collection} types - list of types\n* @returns {IntegerArray} list of data type enumeration constants\n*/\nfunction types2enums( types ) {\n\tvar out;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 0; i < types.length; i++ ) {\n\t\tout.push( resolveEnum( types[ i ] ) ); // note: we're assuming that `types[i]` is a known data type; otherwise, the resolved enum will be `null`\n\t}\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Constructor for applying a strided function to an ndarray.\n*\n* @constructor\n* @param {Object} table - dispatch table\n* @param {Function} table.default - default strided function\n* @param {StringArray} [table.types=[]] - one-dimensional list of ndarray data types describing specialized output ndarray argument signatures\n* @param {ArrayLikeObject<Function>} [table.fcns=[]] - list of strided functions which are specific to specialized output ndarray argument signatures\n* @param {ArrayLikeObject<StringArray>} idtypes - list containing lists of supported input data types for each ndarray argument\n* @param {StringArray} odtypes - list of supported data types\n* @param {Options} [options] - function options\n* @param {boolean} [options.strictTraversalOrder=false] - boolean specifying whether to require that element traversal match the memory layout of an output ndarray\n* @throws {TypeError} first argument must be an object having valid properties\n* @throws {Error} first argument must be an object having valid properties\n* @throws {TypeError} second argument must be an array containing arrays of supported data types\n* @throws {TypeError} third argument must be an array of supported data types\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @returns {NullaryStrided1dDispatch} instance\n*\n* @example\n* import base from '@stdlib/blas-ext-base-ndarray-gsorthp';\n* import dtypes from '@stdlib/ndarray-dtypes';\n* import ndarray2array from '@stdlib/ndarray-to-array';\n* import scalar2ndarray from '@stdlib/ndarray-from-scalar';\n* import ndarray from '@stdlib/ndarray-base-ctor';\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = dtypes( 'all' );\n*\n* var table = {\n*     'default': base\n* };\n* var sorthp = new NullaryStrided1dDispatch( table, [ idt ], odt );\n*\n* var xbuf = [ -1.0, 2.0, -3.0 ];\n* var x = new ndarray( 'generic', xbuf, [ xbuf.length ], [ 1 ], 0, 'row-major' );\n*\n* var order = scalar2ndarray( 1.0, {\n*     'dtype': 'generic'\n* });\n*\n* sorthp.assign( x, order );\n*\n* var arr = ndarray2array( x );\n* // returns [ -3.0, -1.0, 2.0 ]\n*/\nfunction NullaryStrided1dDispatch( table, idtypes, odtypes, options ) {\n\tvar dt;\n\tvar i;\n\tif ( !( this instanceof NullaryStrided1dDispatch ) ) {\n\t\tif ( arguments.length > 3 ) {\n\t\t\treturn new NullaryStrided1dDispatch( table, idtypes, odtypes, options ); // eslint-disable-line max-len\n\t\t}\n\t\treturn new NullaryStrided1dDispatch( table, idtypes, odtypes );\n\t}\n\tif ( !isObject( table ) ) {\n\t\tthrow new TypeError( format( 'null3L', table ) );\n\t}\n\tif ( !isFunction( table.default ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be an object having a \"default\" property and an associated method.' ) );\n\t}\n\tif ( hasProp( table, 'types' ) && !isCollection( table.types ) && !isEmptyCollection( table.types ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be an object having a \"types\" property whose associated value is an array-like object.' ) );\n\t}\n\tif ( hasProp( table, 'fcns' ) && !isFunctionArray( table.fcns ) && !isEmptyCollection( table.fcns ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be an object having a \"fcns\" property whose associated value is an array-like object containing functions.' ) );\n\t}\n\tif ( !isCollection( idtypes ) ) {\n\t\tthrow new TypeError( format( 'null2y', idtypes ) );\n\t}\n\tfor ( i = 0; i < idtypes.length; i++ ) {\n\t\tdt = idtypes[ i ];\n\t\tif (\n\t\t\t!isCollection( dt ) ||\n\t\t\tdt.length < 1 ||\n\t\t\t!everyBy( dt, isDataType )\n\t\t) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Second argument must contain arrays of data types. Value: `%s`.', idtypes ) );\n\t\t}\n\t}\n\tif (\n\t\t!isCollection( odtypes ) ||\n\t\todtypes.length < 1 ||\n\t\t!everyBy( odtypes, isDataType )\n\t) {\n\t\tthrow new TypeError( format( 'invalid argument. Third argument must be an array of data types. Value: `%s`.', odtypes ) );\n\t}\n\tthis._table = {\n\t\t'default': table.default,\n\t\t'types': ( table.types ) ? types2enums( table.types ) : [], // note: convert to enums (i.e., integers) to ensure faster comparisons\n\t\t'fcns': ( table.fcns ) ? copy( table.fcns ) : []\n\t};\n\tif ( this._table.types.length !== this._table.fcns.length ) {\n\t\tthrow new Error( 'invalid argument. First argument specifies an unexpected number of types. An output ndarray data type must be specified for each provided strided function.' );\n\t}\n\tthis._idtypes = idtypes;\n\tthis._odtypes = odtypes;\n\tif ( arguments.length > 3 ) {\n\t\tthis._apply = nullaryStrided1d.factory( options ); // note: delegate options validation to factory method\n\t} else {\n\t\tthis._apply = nullaryStrided1d;\n\t}\n\treturn this;\n}\n\n/**\n* Applies a strided function and assigns results to a provided output ndarray.\n*\n* @name assign\n* @memberof NullaryStrided1dDispatch.prototype\n* @type {Function}\n* @param {ndarrayLike} out - output ndarray\n* @param {...ndarrayLike} [args] - additional ndarray arguments\n* @param {Options} [options] - function options\n* @param {IntegerArray} [options.dims] - list of dimensions over which to perform an operation\n* @throws {TypeError} first argument must be an ndarray\n* @throws {TypeError} first argument must have a supported data type\n* @throws {TypeError} options argument must be an object\n* @throws {RangeError} dimension indices must not exceed output ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of output ndarray dimensions\n* @throws {Error} must provide valid options\n* @returns {ndarrayLike} output ndarray\n*\n* @example\n* import base from '@stdlib/blas-ext-base-ndarray-gsorthp';\n* import dtypes from '@stdlib/ndarray-dtypes';\n* import ndarray2array from '@stdlib/ndarray-to-array';\n* import scalar2ndarray from '@stdlib/ndarray-from-scalar';\n* import ndarray from '@stdlib/ndarray-base-ctor';\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = dtypes( 'all' );\n*\n* var table = {\n*     'default': base\n* };\n* var sorthp = new NullaryStrided1dDispatch( table, [ idt ], odt );\n*\n* var xbuf = [ -1.0, 2.0, -3.0 ];\n* var x = new ndarray( 'generic', xbuf, [ xbuf.length ], [ 1 ], 0, 'row-major' );\n*\n* var order = scalar2ndarray( 1.0, {\n*     'dtype': 'generic'\n* });\n*\n* var out = sorthp.assign( x, order );\n* // returns <ndarray>\n*\n* var arr = ndarray2array( x );\n* // returns [ -3.0, -1.0, 2.0 ]\n*\n* var bool = ( out === x );\n* // returns true\n*/\nsetReadOnly( NullaryStrided1dDispatch.prototype, 'assign', function assign( out ) {\n\tvar options;\n\tvar dtypes;\n\tvar nargs;\n\tvar opts;\n\tvar args;\n\tvar arr;\n\tvar err;\n\tvar flg;\n\tvar odt;\n\tvar dt;\n\tvar N;\n\tvar f;\n\tvar i;\n\n\tnargs = arguments.length;\n\tif ( !isndarrayLike( out ) ) {\n\t\tthrow new TypeError( format( 'null5t', out ) );\n\t}\n\t// Validate the output ndarray data type...\n\todt = getDType( out );\n\tif ( !contains( this._odtypes, odt ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must have one of the following data types: \"%s\". Data type: `%s`.', join( this._odtypes, '\", \"' ), odt ) );\n\t}\n\targs = [ out ];\n\n\t// Resolve additional ndarray arguments...\n\tfor ( i = 1; i < nargs; i++ ) {\n\t\tarr = arguments[ i ];\n\t\tif ( !isndarrayLike( arr ) ) {\n\t\t\tbreak;\n\t\t}\n\t\targs.push( arr );\n\t}\n\t// If we processed all but the last argument, assume that the last argument is an options argument...\n\tif ( i === nargs-1 ) {\n\t\toptions = arguments[ i ];\n\t\tflg = true;\n\t}\n\t// Otherwise, if we have more than one argument remaining, then at least one argument is not an ndarray but should be...\n\telse if ( i < nargs-1 ) {\n\t\tthrow new TypeError( format( 'invalid argument. Argument %d must be an ndarray-like object. Value: `%s`.', i, arguments[ i ] ) );\n\t}\n\t// Verify that additional ndarray arguments have expected dtypes...\n\tfor ( i = 1; i < args.length; i++ ) {\n\t\tdt = getDType( args[ i ] );\n\t\tif ( !contains( this._idtypes[ i-1 ], dt ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Argument %d must have one of the following data types: \"%s\". Data type: `%s`.', i, join( this._idtypes[ i-1 ], '\", \"' ), dt ) );\n\t\t}\n\t}\n\t// Validate any provided options...\n\tN = ndims( out );\n\topts = objectAssign( {}, defaults );\n\tif ( flg ) {\n\t\terr = validate( opts, N, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\t// When a list of dimensions is not provided, apply the strided function across all dimensions...\n\tif ( opts.dims === null ) {\n\t\topts.dims = zeroTo( N );\n\t}\n\t// Resolve the lower-level strided function satisfying the output ndarray data type:\n\tdtypes = [ resolveEnum( odt ) ];\n\ti = indexOfTypes( this._table.fcns.length, 1, this._table.types, 1, 1, 0, dtypes, 1, 0 ); // eslint-disable-line max-len\n\tif ( i >= 0 ) {\n\t\tf = this._table.fcns[ i ];\n\t} else {\n\t\tf = this._table.default;\n\t}\n\t// Perform operation:\n\tthis._apply( f, args, opts.dims ); // note: we assume that this lower-level function handles further validation of the output ndarray (e.g., expected shape, etc)\n\n\treturn out;\n});\n\n\n// EXPORTS //\n\nexport default NullaryStrided1dDispatch;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isObject from '@stdlib/assert-is-plain-object';\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport { primitives as isIntegerArray } from '@stdlib/assert-is-integer-array';\nimport isEmptyCollection from '@stdlib/assert-is-empty-collection';\nimport normalizeIndices from '@stdlib/ndarray-base-to-unique-normalized-indices';\nimport join from '@stdlib/array-base-join';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {NonNegativeInteger} ndims - number of ndarray dimensions\n* @param {Options} options - function options\n* @param {IntegerArray} [options.dims] - list of dimensions over which to perform an operation\n* @returns {(Error|null)} null or an error object\n*\n* @example\n* var opts = {};\n* var options = {\n*     'dims': [ 0 ]\n* };\n* var err = validate( opts, 3, options );\n* if ( err ) {\n*     throw err;\n* }\n*/\nfunction validate( opts, ndims, options ) {\n\tvar tmp;\n\tif ( !isObject( options ) ) {\n\t\treturn new TypeError( format( 'null2V', options ) );\n\t}\n\tif ( hasOwnProp( options, 'dims' ) ) {\n\t\topts.dims = options.dims;\n\t\tif ( !isIntegerArray( opts.dims ) && !isEmptyCollection( opts.dims ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be an array of integers. Option: `%s`.', 'dims', opts.dims ) );\n\t\t}\n\t\ttmp = normalizeIndices( opts.dims, ndims-1 );\n\t\tif ( tmp === null ) {\n\t\t\treturn new RangeError( format( 'invalid option. `%s` option contains an out-of-bounds dimension index. Option: [%s].', 'dims', join( opts.dims, ',' ) ) );\n\t\t}\n\t\tif ( tmp.length !== opts.dims.length ) {\n\t\t\treturn new Error( format( 'invalid option. `%s` option contains duplicate indices. Option: [%s].', 'dims', join( opts.dims, ',' ) ) );\n\t\t}\n\t\topts.dims = tmp;\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\n\nexport default validate;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Returns the first row index at which a given one-dimensional array of types can be found in a two-dimensional reference array of types (or `-1` if not found).\n*\n* ## Notes\n*\n* -   The intended use case for this function is for type dispatch (i.e., given a set of array data types, find a matching interface according the interface's accepted array data types).\n* -   The function assumes that `x` is stored in row-major order.\n* -   The function assumes that the number of indexed elements in `y` equals the number of columns in `x`.\n* -   The function returns a row index. To convert to a linear index, multiply `strideX1` by the return value.\n*\n* @private\n* @param {NonNegativeInteger} N - number of rows in `x` (size of first dimension)\n* @param {NonNegativeInteger} M - number of columns in `x` (size of second dimension)\n* @param {ArrayLikeObject} x - input two-dimensional reference array\n* @param {integer} strideX1 - `x` stride length along first dimension\n* @param {integer} strideX2 - `x` stride length along second dimension\n* @param {NonNegativeInteger} offsetX - `x` starting index\n* @param {ArrayLikeObject} y - search array\n* @param {integer} strideY - `y` stride length\n* @param {NonNegativeInteger} offsetY - `y` starting index\n* @returns {integer} row index (if found) and `-1` otherwise\n*\n* @example\n* // Define a reference array to search:\n* var types = [\n*     'float64', 'float64', 'float64',\n*     'float32', 'float32', 'float32',\n*     'uint32', 'uint32', 'float64',\n*     'int32', 'int32', 'float64',\n*     'uint16', 'uint16', 'float64',\n*     'int16', 'int16', 'float64',\n*     'uint8', 'uint8', 'float64',\n*     'int8', 'int8', 'float64'\n* ];\n*\n* // Define reference array dimensions:\n* var N = 8; // rows\n* var M = 3; // columns\n*\n* // Define a search array:\n* y1 = [\n*     'float32', 'float32', 'float32',\n* ];\n*\n* // Find the list of types:\n* var r1 = indexOfTypes( N, M, types, M, 1, 0, y1, 1, 0 );\n* // returns 1\n*\n// Define a search array:\n* y2 = [\n*     'float32', 'float32', 'float64',\n* ];\n*\n* // Find the list of types:\n* var r2 = indexOfTypes( N, M, types, M, 1, 0, y2, 1, 0 );\n* // returns -1\n*/\nfunction indexOfTypes( N, M, x, strideX1, strideX2, offsetX, y, strideY, offsetY ) { // eslint-disable-line max-len\n\tvar ix;\n\tvar iy;\n\tvar i;\n\tvar j;\n\n\t// Search for the first row which matches `y`...\n\tix = offsetX;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tiy = offsetY;\n\t\tfor ( j = 0; j < M; j++ ) {\n\t\t\tif ( x[ ix+(j*strideX2) ] !== y[ iy ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tiy += strideY;\n\t\t}\n\t\t// If we successfully iterated over all columns, then that means we've found a match...\n\t\tif ( j === M ) {\n\t\t\treturn i;\n\t\t}\n\t\tix += strideX1;\n\t}\n\treturn -1;\n}\n\n\n// EXPORTS //\n\nexport default indexOfTypes;\n"],"names":["types2enums","types","out","i","length","push","resolveEnum","NullaryStrided1dDispatch","table","idtypes","odtypes","options","dt","this","arguments","isObject","TypeError","format","isFunction","default","hasProp","isCollection","isEmptyCollection","isFunctionArray","fcns","everyBy","isDataType","_table","copy","Error","_idtypes","_odtypes","_apply","nullaryStrided1d","factory","setReadOnly","prototype","dtypes","nargs","opts","args","arr","err","flg","odt","N","f","isndarrayLike","getDType","contains","join","ndims","objectAssign","defaults","tmp","hasOwnProp","dims","isIntegerArray","normalizeIndices","RangeError","validate","zeroTo","M","x","strideX1","strideX2","offsetX","y","strideY","offsetY","ix","iy","j","indexOfTypes"],"mappings":"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"}